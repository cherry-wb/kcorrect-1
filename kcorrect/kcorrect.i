/* SWIG interface for Michael Blanton's kcorrect C library

   Written by Taro Sato (ubutsu [at] gmail.com)
 */
%define DOCSTR_MAIN
"Python interface of Michael Blanton's kcorrect C library

This module provides the Pythonic interface to Michael Blanton's
kcorrect C libray functions.  It is generated by SWIG with the
interface written by Taro Sato."
%enddef

%module(docstring=DOCSTR_MAIN) clib
%include "typemaps.i"

%{
/* Includes the header in the wrapper code */
#include "kcorrect.h"
#include "Python.h"
#include "numpy/arrayobject.h"
%}

%init %{
  import_array(); /* Need this to make numpy work!!!! */
%}

#define PyAO PyArrayObject

/*//////////////////////////////////////////////////////////////////////////
// GENERIC TYPEMAPS
//////////////////////////////////////////////////////////////////////////*/

/* for dealing with simple array */

%inline %{

typedef struct {
  float *data;
  IDL_LONG nd;
  IDL_LONG *dims;
} ARRAY;

%}

%typemap(in, numinputs=1) ARRAY *in_array (ARRAY in_array) {
  //printf("in_array for $symname...\n");
  PyObject *o = $input;
  PyAO *a = (PyArray_Check(o)
             ? (PyAO*)PyArray_Cast((PyAO*)o, PyArray_FLOAT)
             : (PyAO*)PyArray_ContiguousFromObject(o, PyArray_FLOAT, 0, 0));
  if (a == NULL) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert to a NumPy array.");
    return NULL;
  }

  $1 = &in_array;
  $1->nd = (IDL_LONG)a->nd;
  $1->dims = (IDL_LONG*)malloc($1->nd * sizeof(IDL_LONG));

  IDL_LONG i, ntotal = 1;
  for (i = 0; i < $1->nd; ++i) {
    $1->dims[i] = a->dimensions[i];
    ntotal *= $1->dims[i];
  }
  //printf("whoo: %d %d %d\n", $1->nd, $1->dims[0], $1->dims[1]);

  $1->data = (float*)malloc(ntotal * sizeof(float));
  float *p = (float*)a->data;

  for (i = 0; i < ntotal; ++i) {
    $1->data[i] = p[i];
  }

  Py_DECREF(a);
}
%typemap(freearg) ARRAY *in_array {
  free($1->data);
  free($1->dims);
}

%typemap(in, numinputs=0) ARRAY *argout_array (ARRAY arr) {
  arr.data = NULL;
  arr.nd = 0;
  arr.dims = NULL;
  $1 = &arr;
}
%typemap(argout) ARRAY *argout_array {
  //printf("argout_array for $symname...\n");
  npy_intp dims[$1->nd];
  IDL_LONG j;
  for(j = 0; j < $1->nd; ++j)
    dims[j] = (int)($1->dims[j]);

  PyAO *rm = (PyAO*)PyArray_SimpleNew($1->nd, dims,
                                      PyArray_FLOAT);
  if (rm == NULL) {
    return NULL;
  }
  float *data = (float*)rm->data;

  IDL_LONG i, n;
  n = 1;
  for (i = 0; i < $1->nd; ++i) n *= $1->dims[i];
  for (i = 0; i < n; ++i) data[i] = $1->data[i];

  int ret;
  PyObject *o;
  if (! $result) {
    $result = PyArray_Return(rm);
  }
  else if ($result == Py_None) {
    Py_DECREF(Py_None);
    $result = PyArray_Return(rm);
  }
  else {
    if (!PyList_Check($result)) {
      o = $result;
      $result = PyList_New(0);
      PyList_Append($result, o);
      Py_XDECREF(o);
    }
    o = PyArray_Return(rm);
    ret = PyList_Append($result, o);
    Py_XDECREF(o);
  }
  free($1->data);
  free($1->dims);
}

/* for dealing with filter information */

%inline %{

typedef struct {
  IDL_LONG nk;              /* number of filters */
  IDL_LONG *filter_n;       /* number of data points in each curve */
  float    *filter_lambda;  /* array of wavelengths */
  float    *filter_pass;    /* array of transmission curve */
  IDL_LONG maxn;            /* max number of curve */
} FILTER_CURVES;

%}

%typemap(in) FILTER_CURVES *in_fcrv (FILTER_CURVES in_fcrv) {
  //printf("In $symname...\n");

  if (!PyList_Check($input)) {
    PyErr_SetString(PyExc_ValueError,
                    "Expecting a list of filter transmission curves");
    return NULL;
  }
  $1 = &in_fcrv;
  $1->nk = PyList_Size($input);
  $1->filter_n = (IDL_LONG*)malloc($1->nk * sizeof(IDL_LONG));
  $1->maxn = 0;

  PyObject *lamb = PyTuple_New($1->nk);
  PyObject *pass = PyTuple_New($1->nk);

  IDL_LONG i;
  for (i = 0; i < $1->nk; ++i) {
    PyObject *tup = PyList_GetItem($input, i);
    if (!PyTuple_Check(tup)) {
      PyErr_SetString(PyExc_ValueError,
                      "Expecting a tuple of filter lambda and pass");
      return NULL;
    }
    PyObject *ol = PyTuple_GetItem(tup, 0);
    PyObject *op = PyTuple_GetItem(tup, 1);

    PyArrayObject *aol, *aop;
    aol = PyArray_Check(ol) ? 
      (PyAO*)PyArray_Cast((PyAO*)ol, PyArray_FLOAT) :
      (PyAO*)PyArray_ContiguousFromObject(ol, PyArray_FLOAT, 0, 0);
    aop = PyArray_Check(op) ? 
      (PyAO*)PyArray_Cast((PyAO*)op, PyArray_FLOAT) :
      (PyAO*)PyArray_ContiguousFromObject(op, PyArray_FLOAT, 0, 0);

    PyTuple_SetItem(lamb, i, (PyObject*)aol);
    PyTuple_SetItem(pass, i, (PyObject*)aop);

    if ($1->maxn < aol->dimensions[0]) $1->maxn = aol->dimensions[0];
    $1->filter_n[i] = aol->dimensions[0];
  }
  $1->filter_lambda = (float*)malloc($1->maxn * $1->nk * sizeof(float));
  $1->filter_pass = (float*)malloc($1->maxn * $1->nk * sizeof(float));
  IDL_LONG j;
  for (i = 0; i < $1->nk; ++i) {
    PyObject *ol = PyTuple_GetItem(lamb, i);
    PyObject *op = PyTuple_GetItem(pass, i);
    PyArrayObject *aol, *aop;
    aol = (PyAO*)PyArray_Cast((PyAO*)ol, PyArray_FLOAT);
    aop = (PyAO*)PyArray_Cast((PyAO*)op, PyArray_FLOAT);
    for (j = 0; j < $1->filter_n[i]; ++j) {
      $1->filter_lambda[$1->maxn*i+j] = 
        *(float*)(aol->data+j*aol->strides[0]);
      $1->filter_pass[$1->maxn*i+j] =
        *(float*)(aop->data+j*aop->strides[0]);
    }
    for (j = $1->filter_n[i]; j < $1->maxn; ++j) {
      $1->filter_lambda[$1->maxn*i+j] = 0.;
      $1->filter_pass[$1->maxn*i+j] = 0.;
    }
  }
  Py_DECREF(lamb);
  Py_DECREF(pass);
}

%typemap(freearg) FILTER_CURVES *in_fcrv {
  free($1->filter_n); free($1->filter_lambda); free($1->filter_pass);
}


/*//////////////////////////////////////////////////////////////////////////
// k_projection_table
//////////////////////////////////////////////////////////////////////////*/

%apply float *INPUT { float *band_shift };

%apply ARRAY *in_array { 
  ARRAY *st_lambda, ARRAY *st_vmatrix, ARRAY *st_zvals
};

%apply ARRAY *argout_array { ARRAY *st_rmatrix };


%feature("docstring") py_k_projection_table
"""k_projection_table(fcrv,lambda,vmatrix,zvals,band_shift)

DESCRIPTION

  Create the rmatrix, a lookup table which speeds analysis

INPUT

  TO BE WRITTEN
""";

%rename(k_projection_table) py_k_projection_table;
%inline %{

void py_k_projection_table( FILTER_CURVES *in_fcrv,
                            ARRAY *st_lambda,
                            ARRAY *st_vmatrix,
                            ARRAY *st_zvals,
                            float band_shift, 
                            ARRAY *st_rmatrix )
{
  IDL_LONG nk, nl, nv, nz, ret;
  nk = in_fcrv->nk;
  nl = st_lambda->dims[0];
  nv = st_vmatrix->dims[0];
  nz = st_zvals->dims[0];

  st_rmatrix->nd = 3;
  st_rmatrix->dims = (IDL_LONG*)malloc(st_rmatrix->nd * sizeof(IDL_LONG));
  st_rmatrix->dims[0] = nk;
  st_rmatrix->dims[1] = nv;
  st_rmatrix->dims[2] = nz;
  st_rmatrix->data = (float*)malloc(nk*nv*nz * sizeof(float));

  ret = k_projection_table(st_rmatrix->data, nk, nv,
                           st_vmatrix->data, st_lambda->data,
                           nl - 1, st_zvals->data, nz,
                           in_fcrv->filter_n,
                           in_fcrv->filter_lambda, 
                           in_fcrv->filter_pass,
                           band_shift, in_fcrv->maxn);
}

%}

%clear FILTER_CURVES *in_fcrv, ARRAY *st_lambda, ARRAY *st_vmatrix,
  ARRAY *st_zvals, float band_shift, ARRAY *st_rmatrix;

/*//////////////////////////////////////////////////////////////////////////
// k_reconstruct_maggies
//////////////////////////////////////////////////////////////////////////*/

%apply ARRAY *in_array {
  ARRAY *st_coeffs, ARRAY *st_redshift, ARRAY *st_zvals, ARRAY *st_rmatrix
};

%apply ARRAY *argout_array { ARRAY *st_reconstruct_maggies };

%feature("docstring") py_k_reconstruct_maggies
"""k_reconstruct_maggies(coeffs,redshift,zvals,rmatrix)

DESCRIPTION

  Interpolate the rmatrix

INPUT

  TO BE WRITTEN
""";

%rename(k_reconstruct_maggies) py_k_reconstruct_maggies;
%inline %{
void py_k_reconstruct_maggies ( ARRAY *st_coeffs,
                                ARRAY *st_redshift,
                                ARRAY *st_zvals,
                                ARRAY *st_rmatrix,
                                ARRAY *st_reconstruct_maggies )
{
  IDL_LONG nz, nk, nv, ngalaxy, ret;
  nz = st_zvals->dims[0];
  nk = st_rmatrix->dims[0];
  nv = st_rmatrix->dims[1];
  ngalaxy = st_redshift->dims[0];

  st_reconstruct_maggies->nd = 2;
  st_reconstruct_maggies->dims = (IDL_LONG*)malloc(2*sizeof(IDL_LONG));
  st_reconstruct_maggies->dims[0] = ngalaxy;
  st_reconstruct_maggies->dims[1] = nk;
  st_reconstruct_maggies->data = (float*)malloc(nk*ngalaxy*sizeof(float));

  ret = k_reconstruct_maggies(st_zvals->data, nz, st_rmatrix->data,
                              nk, nv, st_coeffs->data, st_redshift->data,
                              st_reconstruct_maggies->data, ngalaxy);
}
%}

%clear ARRAY *st_coeffs, ARRAY *st_redshift, ARRAY *st_zvals,
  ARRAY *st_rmatrix, ARRAY *st_reconstruct_maggies;

/*//////////////////////////////////////////////////////////////////////////
// k_fit_nonneg
//////////////////////////////////////////////////////////////////////////*/

%apply int *OUTPUT { IDL_LONG *niter };

%apply ARRAY *in_array {
  ARRAY *st_maggies, ARRAY *st_maggies_ivar, ARRAY *st_redshift,
    ARRAY *st_zvals, ARRAY *st_rmatrix
};

%apply ARRAY *argout_array { ARRAY *st_coeffs, ARRAY *st_chi2 };

%feature("docstring") py_k_fit_nonneg
"""k_fit_nonneg(maggies,maggies_ivar,redshift,zvals,rmatrix,maxiter,tolerange,verbose)

DESCRIPTION

  Nonnegative solutions

INPUT

  TO BE WRITTEN
""";

%rename(k_fit_nonneg) py_k_fit_nonneg;
%inline %{
void py_k_fit_nonneg( ARRAY *st_maggies,
                      ARRAY *st_maggies_ivar,
                      ARRAY *st_redshift,
                      ARRAY *st_zvals,
                      ARRAY *st_rmatrix,
                      int maxiter, float tolerance, int verbose, 
                      ARRAY *st_coeffs, ARRAY *st_chi2, IDL_LONG *niter )
{
  IDL_LONG nk, nv, nz, ngalaxy, ret;
  nk = st_rmatrix->dims[0];
  nv = st_rmatrix->dims[1];
  nz = st_zvals->dims[0];
  ngalaxy = st_redshift->dims[0];

  st_coeffs->nd = 2;
  st_coeffs->dims = (IDL_LONG*)malloc(st_coeffs->nd * sizeof(IDL_LONG));
  st_coeffs->dims[0] = ngalaxy;
  st_coeffs->dims[1] = nv;
  st_coeffs->data = (float*)malloc(ngalaxy*nv * sizeof(float));

  st_chi2->nd = 1;
  st_chi2->dims = (IDL_LONG*)malloc(st_chi2->nd * sizeof(IDL_LONG));
  st_chi2->dims[0] = ngalaxy;
  st_chi2->data = (float*)malloc(ngalaxy * sizeof(float));

  ret = k_fit_nonneg(st_coeffs->data, st_rmatrix->data, nk, nv,
                     st_zvals->data, nz,
                     st_maggies->data, st_maggies_ivar->data, st_redshift->data,
                     ngalaxy, tolerance, (IDL_LONG)maxiter, 
                     niter, st_chi2->data, (IDL_LONG)verbose, 0);
}
%}

%clear ARRAY *st_maggies, ARRAY *st_maggies_ivar, ARRAY *st_redshift,
  ARRAY *st_zvals, ARRAY *st_rmatrix, int maxiter, float tolerance, 
  int verbose, ARRAY *st_coeffs, ARRAY *st_chi2, IDL_LONG *niter;

/*//////////////////////////////////////////////////////////////////////////
// k_fit_photoz
//////////////////////////////////////////////////////////////////////////*/

%apply int *OUTPUT { IDL_LONG *niter };

%apply ARRAY *in_array {
  ARRAY *st_maggies, ARRAY *st_maggies_ivar,
    ARRAY *st_zpriors, ARRAY *st_lpriors,
    ARRAY *st_zvals, ARRAY *st_rmatrix
};

%apply ARRAY *argout_array {
  ARRAY *st_photoz, ARRAY *st_coeffs, ARRAY *st_chi2
};

%feature("docstring") py_k_fit_photoz
"""k_fit_photoz(maggies,maggies_ivar,redshift,zvals,rmatrix,maxiter,tolerange,verbose)

DESCRIPTION

  Get photometric redshifts

INPUT

  TO BE WRITTEN
""";

%rename(k_fit_photoz) py_k_fit_photoz;
%inline %{
void py_k_fit_photoz( ARRAY *st_maggies,
                      ARRAY *st_maggies_ivar,
                      ARRAY *st_zpriors,
                      ARRAY *st_lpriors,
                      ARRAY *st_zvals,
                      ARRAY *st_rmatrix,
                      int maxiter, float tolerance, int verbose, 
                      ARRAY *st_photoz, ARRAY *st_coeffs, ARRAY *st_chi2,
                      IDL_LONG *niter )
{
  IDL_LONG nk, nv, nz, ngalaxy, nprior, ret;
  nk = st_rmatrix->dims[0];
  nv = st_rmatrix->dims[1];
  nz = st_zvals->dims[0];
  ngalaxy = st_maggies->dims[0];
  nprior = st_lpriors->dims[0];

  st_photoz->nd = 1;
  st_photoz->dims = (IDL_LONG*)malloc(st_photoz->nd * sizeof(IDL_LONG));
  st_photoz->dims[0] = ngalaxy;
  st_photoz->data = (float*)malloc(ngalaxy * sizeof(float));

  st_coeffs->nd = 2;
  st_coeffs->dims = (IDL_LONG*)malloc(st_coeffs->nd * sizeof(IDL_LONG));
  st_coeffs->dims[0] = ngalaxy;
  st_coeffs->dims[1] = nv;
  st_coeffs->data = (float*)malloc(ngalaxy * nv * sizeof(float));

  st_chi2->nd = 1;
  st_chi2->dims = (IDL_LONG*)malloc(st_chi2->nd * sizeof(IDL_LONG));
  st_chi2->dims[0] = ngalaxy;
  st_chi2->data = (float*)malloc(ngalaxy * sizeof(float));

  ret = k_fit_photoz(st_photoz->data,
                     st_coeffs->data,
                     st_rmatrix->data, nk, nv,
                     st_zpriors->data, st_lpriors->data, nprior,
                     st_zvals->data, nz,
                     st_maggies->data, st_maggies_ivar->data, ngalaxy,
                     tolerance, (IDL_LONG)maxiter, 
                     niter, st_chi2->data, (IDL_LONG)verbose);
}
%}

%clear ARRAY *st_maggies, ARRAY *st_maggies_ivar,
  ARRAY *st_zprior, ARRAY *st_lprior,
  ARRAY *st_zvals, ARRAY *st_rmatrix, int maxiter, float tolerance, 
  int verbose, ARRAY *st_photoz, ARRAY *st_coeffs, ARRAY *st_chi2,
  IDL_LONG *niter;


/*///////////////////////////////////////////////////////////////////////////
// k_read_ascii_table
///////////////////////////////////////////////////////////////////////////*/

%apply ARRAY *argout_array { ARRAY *table };

%feature("docstring") py_k_read_ascii_table
"""k_read_ascii_table(fname)

DESCRIPTION

  Read an ASCII file in the following format, which is:
 
    <ndim> <size_{0}> ... <size_{ndim-1}>
    <entry_0>
    <entry_1>
    ...
    <entry_n>
    ...
    <entry_{size_0*size_1*..*size_{ndim-1}-1>
 
  where the table element [k,j,i] (for ndim==3) would be the entry
  element n, where n=i*size_2*size1+j*size2+k.

INPUT

  fname -- Path to an ASCII file
""";

%rename(k_read_ascii_table) py_k_read_ascii_table;
%inline %{
void py_k_read_ascii_table(char *fname, ARRAY *table)
{
  IDL_LONG ret;
  ret = k_read_ascii_table(&(table->data), &(table->nd), &(table->dims),
                           fname);
}
%}

%clear char *fname, ARRAY *table;


/*****************************************************************************
 * Other functions
 *****************************************************************************/

// The functions in the C library to be specified in this section can
// only accomodate certain cosmologies.  if a cosmology not allowed is
// given, the program simply exits within the C library routine.  by
// trapping such a case by "check_omegas", we want a python execption
// to be thrown instead.
%inline %{
#define TOL 1.e-6 
int _check_omegas(float omega0, float omegal0)
{
  int ret;
  if((fabs(omega0 + omegal0 - 1.) < TOL)
     || (fabs(omegal0) < TOL && omega0 <= 1. && omega0 >= 0.))
    ret = 0;
  else
    ret = 1;
  return ret;
}
%}


// A generic typemap to handle cosmological parameters; currently only
// handles (O_m, O_L), and h (normalized to 100 km/s/Mpc) is assumed to
// be one.
%typemap(in) (float omega0, float omegal0) {
  // check if the cosmo params are given as a sequence.
  if (! PySequence_Check($input) || PySequence_Size($input) != 2) {
    PyErr_SetString(PyExc_ValueError,
                    "Expecting (Omega_matter, Omega_Lambda).");
    return NULL;
  }
  // store omega0 and omegal0.
  $1 = (float)PyFloat_AsDouble(PySequence_GetItem($input, 0));
  $2 = (float)PyFloat_AsDouble(PySequence_GetItem($input, 1));
  // check if the cosmo parameters are allowed.
  if (_check_omegas($1, $2)) {
    PyErr_SetString(PyExc_ValueError,
                    "The input cosmology is not supported.");
    return NULL;
  }
}

%typemap(in) (float floatvalue) {
  $1 = (float)PyFloat_AsDouble($input);
  if (PyErr_Occurred()) {
    PyErr_SetString(PyExc_ValueError,
                    "Problem converting to float type.");
    return NULL;
  }
}

%apply float floatvalue { float z, float V, float r, float dm };


/***
 * functions from kcorrect.h 
 */

%feature("docstring") ztor
"""ztor(z, cosmo)

DESCRIPTION

  Converts redshift z into comoving distance r in km.

INPUT

  z -- Redshift
  cosmo -- Cosmology given as tuple of the form (omega0, omegal0)
""";
float ztor(float z, float omega0, float omegal0);

%feature("docstring") ztodV
"""ztodV(z, cosmo)

DESCRIPTION

  Converts redshift z to comoving volume element dV in h^-3 Mpc^3.

INPUT

  z -- Redshift
  cosmo -- Cosmology given as tuple of the form (omega0, omegal0)
""";
float ztodV(float z, float omega0, float omegal0);


%rename(ztov) ztoV;
%feature("docstring") ztoV
"""
ztov(z, cosmo)

Convert redshift z to comoving enclosed volume in h^-3 Mpc^3.

Parameters
----------
z : float
    A redshift value.
cosmo : (Omega_matter, Omega_Lambda)
    Cosmology given as a tuple.
""";
float ztoV(float z, float omega0, float omegal0);


%feature("docstring") Vtoz
"""Vtoz(V, cosmo)

DESCRIPTION

  Converts comoving enclosed volume in h^-3 Mpc^3 to redshift z.

INPUT

  V -- Comoving enclosed volume in h^-3 Mpc^3
  cosmo -- Cosmology given as tuple of the form (omega0, omegal0)
""";
float Vtoz(float V, float omega0, float omegal0);

%feature("docstring") rtoz
"""rtoz(r, cosmo)

DESCRIPTION

  Converts comoving distance r in km to redshift z.

INPUT

  r -- Comoving distance in km
  cosmo -- Cosmology given as tuple of the form (omega0, omegal0)
""";
float rtoz(float r, float omega0, float omegal0);


%rename(ztodm) z2dm;
%feature("docstring") z2dm
"""
ztodm(z, cosmo)

Convert a redshift z into the distance modulus dm.

Parameters
----------
z : float
    A redshift value.
cosmo : (Omega_matter, Omega_Lambda)
    Cosmology given as a tuple.
""";
float z2dm(float z, float omega0, float omegal0);


%feature("docstring") dm2z
"""dm2z(dm, cosmo)

DESCRIPTION

  Converts distance modulus dm into redshift z.

INPUT

  dm -- Distance measure
  cosmo -- Cosmology given as tuple of the form (omega0, omegal0)
""";
float dm2z(float dm, float omega0, float omegal0);

%feature("docstring") z2add
"""z2add(z, cosmo)

DESCRIPTION

  Gives the angular diameter distance in km/s at redshift z.

INPUT

  z -- Redshift
  cosmo -- Cosmology given as tuple of the form (omega0, omegal0)
""";
float z2add(float z, float omega0, float omegal0);

%feature("docstring") z2t
"""z2t(z, cosmo)

DESCRIPTION

  Returns the age of universe at redshift z in h^-1 Gyr.

INPUT

  z -- Redshift
  cosmo -- Cosmology given as tuple of the form (omega0, omegal0)
""";
float z2t(float z, float omega0, float omegal0);

%feature("docstring") t2z
"""t2z(t, cosmo)

DESCRIPTION

  Returns the redshift z given the age of universe in h^-1 Gyr.

INPUT

  t -- Age of universe in h^-1 Gyr
  cosmo -- Cosmology given as tuple of the form (omega0, omegal0)
""";
float t2z(float z, float omega0, float omegal0);
