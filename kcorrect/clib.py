# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.4
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


"""
Python interface of Michael Blanton's kcorrect C library

This module provides the Pythonic interface to Michael Blanton's
kcorrect C libray functions.  It is generated by SWIG with the
interface written by Taro Sato.
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_clib', [dirname(__file__)])
        except ImportError:
            import _clib
            return _clib
        if fp is not None:
            try:
                _mod = imp.load_module('_clib', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _clib = swig_import_helper()
    del swig_import_helper
else:
    import _clib
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class ARRAY(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ARRAY, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ARRAY, name)
    __repr__ = _swig_repr
    __swig_setmethods__["data"] = _clib.ARRAY_data_set
    __swig_getmethods__["data"] = _clib.ARRAY_data_get
    if _newclass:data = _swig_property(_clib.ARRAY_data_get, _clib.ARRAY_data_set)
    __swig_setmethods__["nd"] = _clib.ARRAY_nd_set
    __swig_getmethods__["nd"] = _clib.ARRAY_nd_get
    if _newclass:nd = _swig_property(_clib.ARRAY_nd_get, _clib.ARRAY_nd_set)
    __swig_setmethods__["dims"] = _clib.ARRAY_dims_set
    __swig_getmethods__["dims"] = _clib.ARRAY_dims_get
    if _newclass:dims = _swig_property(_clib.ARRAY_dims_get, _clib.ARRAY_dims_set)
    def __init__(self): 
        this = _clib.new_ARRAY()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _clib.delete_ARRAY
    __del__ = lambda self : None;
ARRAY_swigregister = _clib.ARRAY_swigregister
ARRAY_swigregister(ARRAY)

class FILTER_CURVES(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FILTER_CURVES, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FILTER_CURVES, name)
    __repr__ = _swig_repr
    __swig_setmethods__["nk"] = _clib.FILTER_CURVES_nk_set
    __swig_getmethods__["nk"] = _clib.FILTER_CURVES_nk_get
    if _newclass:nk = _swig_property(_clib.FILTER_CURVES_nk_get, _clib.FILTER_CURVES_nk_set)
    __swig_setmethods__["filter_n"] = _clib.FILTER_CURVES_filter_n_set
    __swig_getmethods__["filter_n"] = _clib.FILTER_CURVES_filter_n_get
    if _newclass:filter_n = _swig_property(_clib.FILTER_CURVES_filter_n_get, _clib.FILTER_CURVES_filter_n_set)
    __swig_setmethods__["filter_lambda"] = _clib.FILTER_CURVES_filter_lambda_set
    __swig_getmethods__["filter_lambda"] = _clib.FILTER_CURVES_filter_lambda_get
    if _newclass:filter_lambda = _swig_property(_clib.FILTER_CURVES_filter_lambda_get, _clib.FILTER_CURVES_filter_lambda_set)
    __swig_setmethods__["filter_pass"] = _clib.FILTER_CURVES_filter_pass_set
    __swig_getmethods__["filter_pass"] = _clib.FILTER_CURVES_filter_pass_get
    if _newclass:filter_pass = _swig_property(_clib.FILTER_CURVES_filter_pass_get, _clib.FILTER_CURVES_filter_pass_set)
    __swig_setmethods__["maxn"] = _clib.FILTER_CURVES_maxn_set
    __swig_getmethods__["maxn"] = _clib.FILTER_CURVES_maxn_get
    if _newclass:maxn = _swig_property(_clib.FILTER_CURVES_maxn_get, _clib.FILTER_CURVES_maxn_set)
    def __init__(self): 
        this = _clib.new_FILTER_CURVES()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _clib.delete_FILTER_CURVES
    __del__ = lambda self : None;
FILTER_CURVES_swigregister = _clib.FILTER_CURVES_swigregister
FILTER_CURVES_swigregister(FILTER_CURVES)


def k_projection_table(*args):
  """
    k_projection_table(fcrv,lambda,vmatrix,zvals,band_shift)

    DESCRIPTION

      Create the rmatrix, a lookup table which speeds analysis

    INPUT

      TO BE WRITTEN

    """
  return _clib.k_projection_table(*args)

def k_reconstruct_maggies(*args):
  """
    k_reconstruct_maggies(coeffs,redshift,zvals,rmatrix)

    DESCRIPTION

      Interpolate the rmatrix

    INPUT

      TO BE WRITTEN

    """
  return _clib.k_reconstruct_maggies(*args)

def k_fit_nonneg(*args):
  """
    k_fit_nonneg(maggies,maggies_ivar,redshift,zvals,rmatrix,maxiter,tolerange,verbose)

    DESCRIPTION

      Nonnegative solutions

    INPUT

      TO BE WRITTEN

    """
  return _clib.k_fit_nonneg(*args)

def k_fit_photoz(*args):
  """
    k_fit_photoz(maggies,maggies_ivar,redshift,zvals,rmatrix,maxiter,tolerange,verbose)

    DESCRIPTION

      Get photometric redshifts

    INPUT

      TO BE WRITTEN

    """
  return _clib.k_fit_photoz(*args)

def k_read_ascii_table(*args):
  """
    k_read_ascii_table(fname)

    DESCRIPTION

      Read an ASCII file in the following format, which is:
     
        <ndim> <size_{0}> ... <size_{ndim-1}>
        <entry_0>
        <entry_1>
        ...
        <entry_n>
        ...
        <entry_{size_0*size_1*..*size_{ndim-1}-1>
     
      where the table element [k,j,i] (for ndim==3) would be the entry
      element n, where n=i*size_2*size1+j*size2+k.

    INPUT

      fname -- Path to an ASCII file

    """
  return _clib.k_read_ascii_table(*args)
TOL = _clib.TOL

def _check_omegas(*args):
  return _clib._check_omegas(*args)
_check_omegas = _clib._check_omegas

def ztor(*args):
  """
    ztor(z, cosmo)

    DESCRIPTION

      Converts redshift z into comoving distance r in km.

    INPUT

      z -- Redshift
      cosmo -- Cosmology given as tuple of the form (omega0, omegal0)

    """
  return _clib.ztor(*args)

def ztodV(*args):
  """
    ztodV(z, cosmo)

    DESCRIPTION

      Converts redshift z to comoving volume element dV in h^-3 Mpc^3.

    INPUT

      z -- Redshift
      cosmo -- Cosmology given as tuple of the form (omega0, omegal0)

    """
  return _clib.ztodV(*args)

def ztov(*args):
  """
    ztov(z, cosmo)

    Convert redshift z to comoving enclosed volume in h^-3 Mpc^3.

    Parameters
    ----------
    z : float
        A redshift value.
    cosmo : (Omega_matter, Omega_Lambda)
        Cosmology given as a tuple.

    """
  return _clib.ztov(*args)

def Vtoz(*args):
  """
    Vtoz(V, cosmo)

    DESCRIPTION

      Converts comoving enclosed volume in h^-3 Mpc^3 to redshift z.

    INPUT

      V -- Comoving enclosed volume in h^-3 Mpc^3
      cosmo -- Cosmology given as tuple of the form (omega0, omegal0)

    """
  return _clib.Vtoz(*args)

def rtoz(*args):
  """
    rtoz(r, cosmo)

    DESCRIPTION

      Converts comoving distance r in km to redshift z.

    INPUT

      r -- Comoving distance in km
      cosmo -- Cosmology given as tuple of the form (omega0, omegal0)

    """
  return _clib.rtoz(*args)

def ztodm(*args):
  """
    ztodm(z, cosmo)

    Convert a redshift z into the distance modulus dm.

    Parameters
    ----------
    z : float
        A redshift value.
    cosmo : (Omega_matter, Omega_Lambda)
        Cosmology given as a tuple.

    """
  return _clib.ztodm(*args)

def dm2z(*args):
  """
    dm2z(dm, cosmo)

    DESCRIPTION

      Converts distance modulus dm into redshift z.

    INPUT

      dm -- Distance measure
      cosmo -- Cosmology given as tuple of the form (omega0, omegal0)

    """
  return _clib.dm2z(*args)

def z2add(*args):
  """
    z2add(z, cosmo)

    DESCRIPTION

      Gives the angular diameter distance in km/s at redshift z.

    INPUT

      z -- Redshift
      cosmo -- Cosmology given as tuple of the form (omega0, omegal0)

    """
  return _clib.z2add(*args)

def z2t(*args):
  """
    z2t(z, cosmo)

    DESCRIPTION

      Returns the age of universe at redshift z in h^-1 Gyr.

    INPUT

      z -- Redshift
      cosmo -- Cosmology given as tuple of the form (omega0, omegal0)

    """
  return _clib.z2t(*args)

def t2z(*args):
  """
    t2z(t, cosmo)

    DESCRIPTION

      Returns the redshift z given the age of universe in h^-1 Gyr.

    INPUT

      t -- Age of universe in h^-1 Gyr
      cosmo -- Cosmology given as tuple of the form (omega0, omegal0)

    """
  return _clib.t2z(*args)
# This file is compatible with both classic and new-style classes.


